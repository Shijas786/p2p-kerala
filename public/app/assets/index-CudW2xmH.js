const __vite__mapDeps=(i,m=__vite__mapDeps,d=(m.f||(m.f=["assets/index-CfvKrXyt.js","assets/index-Cycn2SnR.js","assets/index-DNUK-TFD.css","assets/hashTypedData-DoQccn9F.js","assets/index-DX5vLSUl.js"])))=>i.map(i=>d[i]);
import{aJ as P,aK as S,aL as B,aM as z,aN as O,aO as b,ad as C,aP as _,aQ as F,aR as j,aS as x,ab as J,a8 as H,aT as L,aU as m,aV as E,aW as Y,aX as T,aY as K}from"./index-Cycn2SnR.js";import{aZ as ot}from"./index-Cycn2SnR.js";function X(g,{body:I,onError:d,onResponse:l}){return g.request({body:I,onError:d,onResponse:l}),g}async function $(g,{body:I,timeout:d=1e4}){return g.requestAsync({body:I,timeout:d})}const U={http(g,I){return P(g).request(I)},webSocket:X,webSocketAsync:$};Q.type="mock";function Q(g){const I=new Map,d=g.features??{defaultConnected:!1};let l=d.defaultConnected,w;return S(a=>({id:"mock",name:"Mock Connector",type:Q.type,async setup(){w=a.chains[0].id},async connect({chainId:t,withCapabilities:i}={}){if(d.connectError)throw typeof d.connectError=="boolean"?new j(new Error("Failed to connect.")):d.connectError;const o=await(await this.getProvider()).request({method:"eth_requestAccounts"});let e=await this.getChainId();return t&&e!==t&&(e=(await this.switchChain({chainId:t})).id),l=!0,{accounts:i?o.map(s=>({address:z(s),capabilities:{foo:{bar:s}}})):o.map(s=>z(s)),chainId:e}},async disconnect(){l=!1},async getAccounts(){if(!l)throw new F;return(await(await this.getProvider()).request({method:"eth_accounts"})).map(c=>z(c))},async getChainId(){const i=await(await this.getProvider()).request({method:"eth_chainId"});return _(i,"number")},async isAuthorized(){return!d.reconnect||!l?!1:!!(await this.getAccounts()).length},async switchChain({chainId:t}){const i=await this.getProvider(),c=a.chains.find(o=>o.id===t);if(!c)throw new O(new b);return await i.request({method:"wallet_switchEthereumChain",params:[{chainId:C(t)}]}),c},onAccountsChanged(t){t.length===0?this.onDisconnect():a.emitter.emit("change",{accounts:t.map(i=>z(i))})},onChainChanged(t){const i=Number(t);a.emitter.emit("change",{chainId:i})},async onDisconnect(t){a.emitter.emit("disconnect"),l=!1},async getProvider({chainId:t}={}){const c=(a.chains.find(e=>e.id===t)??a.chains[0]).rpcUrls.default.http[0];return B({request:async({method:e,params:s})=>{if(e==="eth_chainId")return C(w);if(e==="eth_accounts"||e==="eth_requestAccounts")return g.accounts;if(e==="eth_signTypedData_v4"&&d.signTypedDataError)throw typeof d.signTypedDataError=="boolean"?new j(new Error("Failed to sign typed data.")):d.signTypedDataError;if(e==="wallet_switchEthereumChain"){if(d.switchChainError)throw typeof d.switchChainError=="boolean"?new j(new Error("Failed to switch chain.")):d.switchChainError;w=_(s[0].chainId,"number"),this.onChainChanged(w.toString());return}if(e==="wallet_watchAsset"){if(d.watchAssetError)throw typeof d.watchAssetError=="boolean"?new j(new Error("Failed to switch chain.")):d.watchAssetError;return l}if(e==="wallet_getCapabilities")return{"0x2105":{paymasterService:{supported:s[0]==="0x95132632579b073D12a6673e18Ab05777a6B86f8"},sessionKeys:{supported:!0}},"0x14A34":{paymasterService:{supported:s[0]==="0x95132632579b073D12a6673e18Ab05777a6B86f8"}}};if(e==="wallet_sendCalls"){const M=[],y=s[0].calls,u=s[0].from;for(const p of y){const{result:D,error:N}=await U.http(c,{body:{method:"eth_sendTransaction",params:[{...p,...typeof u<"u"?{from:u}:{}}]}});if(N)throw new x({body:{method:e,params:s},error:N,url:c});M.push(D)}const f=J(H(JSON.stringify(y)));return I.set(f,M),{id:f}}if(e==="wallet_getCallsStatus"){const M=I.get(s[0]);if(!M)return{atomic:!1,chainId:"0x1",id:s[0],status:100,receipts:[],version:"2.0.0"};const u=(await Promise.all(M.map(async f=>{const{result:p,error:D}=await U.http(c,{body:{method:"eth_getTransactionReceipt",params:[f],id:0}});if(D)throw new x({body:{method:e,params:s},error:D,url:c});return p?{blockHash:p.blockHash,blockNumber:p.blockNumber,gasUsed:p.gasUsed,logs:p.logs,status:p.status,transactionHash:p.transactionHash}:null}))).filter(f=>f!==null);return u.length===0?{atomic:!1,chainId:"0x1",id:s[0],status:100,receipts:[],version:"2.0.0"}:{atomic:!1,chainId:"0x1",id:s[0],status:200,receipts:u,version:"2.0.0"}}if(e==="wallet_showCallsStatus")return;if(e==="personal_sign"){if(d.signMessageError)throw typeof d.signMessageError=="boolean"?new j(new Error("Failed to sign message.")):d.signMessageError;e="eth_sign",s=[s[1],s[0]]}const n={method:e,params:s},{error:r,result:h}=await U.http(c,{body:n});if(r)throw new x({body:n,error:r,url:c});return h}})({retryCount:0})}}))}function q(g){var a,t,i;const{chain:I}=g,d=I.rpcUrls.default.http[0];if(!g.transports)return[d];const l=(t=(a=g.transports)==null?void 0:a[I.id])==null?void 0:t.call(a,{chain:I});return(((i=l==null?void 0:l.value)==null?void 0:i.transports)||[l]).map(({value:c})=>(c==null?void 0:c.url)||d)}function et(g={}){let I,d,l,w;return S(a=>({id:"baseAccount",name:"Base Account",rdns:"app.base.account",type:"baseAccount",async connect({chainId:t,withCapabilities:i,...c}={}){var o;try{const e=await this.getProvider(),s=t??((o=a.chains[0])==null?void 0:o.id);if(!s)throw new b;let{accounts:n,currentChainId:r}=await(async()=>{if(c.isReconnecting)return{accounts:(await e.request({method:"eth_accounts",params:[]})).map(u=>({address:z(u)})),currentChainId:await this.getChainId()};const h=await e.request({method:"wallet_connect",params:[{capabilities:"capabilities"in c&&c.capabilities?c.capabilities:{},chainIds:[C(s),...a.chains.filter(u=>u.id!==s).map(u=>C(u.id))]}]});return{accounts:(await e.request({method:"eth_accounts"})).map(u=>h.accounts.find(f=>f.address===u)??{address:u}).map(u=>({address:z(u.address),capabilities:u.capabilities??{}})),currentChainId:Number(h.chainIds[0])}})();if(d||(d=this.onAccountsChanged.bind(this),e.on("accountsChanged",d)),l||(l=this.onChainChanged.bind(this),e.on("chainChanged",l)),w||(w=this.onDisconnect.bind(this),e.on("disconnect",w)),t&&r!==t){const h=await this.switchChain({chainId:t}).catch(M=>{if(M.code===j.code)throw M;return{id:r}});r=(h==null?void 0:h.id)??r}return{accounts:i?n:n.map(h=>h.address),chainId:r}}catch(e){throw/(user closed modal|accounts received is empty|user denied account|request rejected)/i.test(e.message)?new j(e):e}},async disconnect(){const t=await this.getProvider();d&&(t.removeListener("accountsChanged",d),d=void 0),l&&(t.removeListener("chainChanged",l),l=void 0),w&&(t.removeListener("disconnect",w),w=void 0),t.disconnect()},async getAccounts(){return(await(await this.getProvider()).request({method:"eth_accounts"})).map(i=>z(i))},async getChainId(){const i=await(await this.getProvider()).request({method:"eth_chainId"});return Number(i)},async getProvider(){if(!I){const t=(()=>{var o;return typeof g.preference=="string"?{options:g.preference}:{...g.preference,options:((o=g.preference)==null?void 0:o.options)??"all"}})(),{createBaseAccountSDK:i}=await(()=>{try{return L(()=>import("./connectors-BkiAkXrA.js"),[])}catch{throw new Error('dependency "@base-org/account" not found')}})();I=i({...g,appChainIds:a.chains.map(o=>o.id),preference:t}).getProvider()}return I},async isAuthorized(){try{return!!(await this.getAccounts()).length}catch{return!1}},async switchChain({addEthereumChainParameter:t,chainId:i}){var e,s,n,r;const c=a.chains.find(h=>h.id===i);if(!c)throw new O(new b);const o=await this.getProvider();try{return await o.request({method:"wallet_switchEthereumChain",params:[{chainId:C(c.id)}]}),c}catch(h){if(h.code===4902)try{let M;t!=null&&t.blockExplorerUrls?M=t.blockExplorerUrls:M=(e=c.blockExplorers)!=null&&e.default.url?[(s=c.blockExplorers)==null?void 0:s.default.url]:[];let y;(n=t==null?void 0:t.rpcUrls)!=null&&n.length?y=t.rpcUrls:y=[((r=c.rpcUrls.default)==null?void 0:r.http[0])??""];const u={blockExplorerUrls:M,chainId:C(i),chainName:(t==null?void 0:t.chainName)??c.name,iconUrls:t==null?void 0:t.iconUrls,nativeCurrency:(t==null?void 0:t.nativeCurrency)??c.nativeCurrency,rpcUrls:y};return await o.request({method:"wallet_addEthereumChain",params:[u]}),c}catch(M){throw new j(M)}throw new O(h)}},onAccountsChanged(t){t.length===0?this.onDisconnect():a.emitter.emit("change",{accounts:t.map(i=>z(i))})},onChainChanged(t){const i=Number(t);a.emitter.emit("change",{chainId:i})},async onDisconnect(t){a.emitter.emit("disconnect");const i=await this.getProvider();d&&(i.removeListener("accountsChanged",d),d=void 0),l&&(i.removeListener("chainChanged",l),l=void 0),w&&(i.removeListener("disconnect",w),w=void 0)}}))}R.type="coinbaseWallet";function R(g={}){let I,d,l,w;return S(a=>({id:"coinbaseWalletSDK",name:"Coinbase Wallet",rdns:"com.coinbase.wallet",type:R.type,async connect({chainId:t,withCapabilities:i,...c}={}){try{const o=await this.getProvider(),e=(await o.request({method:"eth_requestAccounts",params:"instantOnboarding"in c&&c.instantOnboarding?[{onboarding:"instant"}]:[]})).map(n=>z(n));d||(d=this.onAccountsChanged.bind(this),o.on("accountsChanged",d)),l||(l=this.onChainChanged.bind(this),o.on("chainChanged",l)),w||(w=this.onDisconnect.bind(this),o.on("disconnect",w));let s=await this.getChainId();if(t&&s!==t){const n=await this.switchChain({chainId:t}).catch(r=>{if(r.code===j.code)throw r;return{id:s}});s=(n==null?void 0:n.id)??s}return{accounts:i?e.map(n=>({address:n,capabilities:{}})):e,chainId:s}}catch(o){throw/(user closed modal|accounts received is empty|user denied account|request rejected)/i.test(o.message)?new j(o):o}},async disconnect(){var i;const t=await this.getProvider();d&&(t.removeListener("accountsChanged",d),d=void 0),l&&(t.removeListener("chainChanged",l),l=void 0),w&&(t.removeListener("disconnect",w),w=void 0),t.disconnect(),(i=t.close)==null||i.call(t)},async getAccounts(){return(await(await this.getProvider()).request({method:"eth_accounts"})).map(i=>z(i))},async getChainId(){const i=await(await this.getProvider()).request({method:"eth_chainId"});return Number(i)},async getProvider(){if(!I){const{createCoinbaseWalletSDK:t}=await(()=>{try{return L(()=>import("./connectors-mXb62Iam.js"),[])}catch{throw new Error('dependency "@coinbase/wallet-sdk" not found')}})();I=t({...g,appChainIds:a.chains.map(c=>c.id),preference:{options:"all",...g.preference??{}}}).getProvider()}return I},async isAuthorized(){try{return!!(await this.getAccounts()).length}catch{return!1}},async switchChain({addEthereumChainParameter:t,chainId:i}){var e,s,n,r;const c=a.chains.find(h=>h.id===i);if(!c)throw new O(new b);const o=await this.getProvider();try{return await o.request({method:"wallet_switchEthereumChain",params:[{chainId:C(c.id)}]}),c}catch(h){if(h.code===4902)try{let M;t!=null&&t.blockExplorerUrls?M=t.blockExplorerUrls:M=(e=c.blockExplorers)!=null&&e.default.url?[(s=c.blockExplorers)==null?void 0:s.default.url]:[];let y;(n=t==null?void 0:t.rpcUrls)!=null&&n.length?y=t.rpcUrls:y=[((r=c.rpcUrls.default)==null?void 0:r.http[0])??""];const u={blockExplorerUrls:M,chainId:C(i),chainName:(t==null?void 0:t.chainName)??c.name,iconUrls:t==null?void 0:t.iconUrls,nativeCurrency:(t==null?void 0:t.nativeCurrency)??c.nativeCurrency,rpcUrls:y};return await o.request({method:"wallet_addEthereumChain",params:[u]}),c}catch(M){throw new j(M)}throw new O(h)}},onAccountsChanged(t){t.length===0?this.onDisconnect():a.emitter.emit("change",{accounts:t.map(i=>z(i))})},onChainChanged(t){const i=Number(t);a.emitter.emit("change",{chainId:i})},async onDisconnect(t){a.emitter.emit("disconnect");const i=await this.getProvider();d&&(i.removeListener("accountsChanged",d),d=void 0),l&&(i.removeListener("chainChanged",l),l=void 0),w&&(i.removeListener("disconnect",w),w=void 0)}}))}W.type="gemini";function W(g={}){let I,d,l,w;return S(a=>({id:"gemini",name:"Gemini Wallet",type:W.type,icon:"https://keys.gemini.com/images/gemini-wallet-logo.svg",async connect({chainId:t,withCapabilities:i}={}){try{const c=await this.getProvider(),o=await c.request({method:"eth_requestAccounts"});d||(d=this.onAccountsChanged.bind(this),c.on("accountsChanged",d)),l||(l=this.onChainChanged.bind(this),c.on("chainChanged",l)),w||(w=this.onDisconnect.bind(this),c.on("disconnect",w));let e=await this.getChainId();if(t&&e!==t){const s=await this.switchChain({chainId:t}).catch(n=>{if(n.code===j.code)throw n;return{id:e}});e=(s==null?void 0:s.id)??e}return{accounts:i?o.map(s=>({address:s,capabilities:{}})):o,chainId:e}}catch(c){throw/(user closed modal|accounts received is empty|user denied account|request rejected)/i.test(c.message)?new j(c):c}},async disconnect(){const t=await this.getProvider();d&&(t.removeListener("accountsChanged",d),d=void 0),l&&(t.removeListener("chainChanged",l),l=void 0),w&&(t.removeListener("disconnect",w),w=void 0),await t.disconnect()},async getAccounts(){return(await(await this.getProvider()).request({method:"eth_accounts"})).map(c=>z(c))},async getChainId(){const i=await(await this.getProvider()).request({method:"eth_chainId"});return Number(i)},async getProvider(){var t,i,c,o;if(!I){const{GeminiWalletProvider:e}=await(()=>{try{return L(()=>import("./connectors-DAWtxdNk.js"),[])}catch{throw new Error('dependency "@gemini-wallet/core" not found')}})();I=new e({appMetadata:g.appMetadata??{},chain:{id:((t=a.chains[0])==null?void 0:t.id)??1,rpcUrl:(o=(c=(i=a.chains[0])==null?void 0:i.rpcUrls)==null?void 0:c.default)==null?void 0:o.http[0]}})}return I},async isAuthorized(){try{return!!(await this.getAccounts()).length}catch{return!1}},async switchChain({chainId:t}){const i=a.chains.find(o=>o.id===t);if(!i)throw new O(new b);const c=await this.getProvider();try{return await c.request({method:"wallet_switchEthereumChain",params:[{chainId:C(t)}]}),i}catch(o){throw new O(o)}},onAccountsChanged(t){t.length===0?this.onDisconnect():a.emitter.emit("change",{accounts:t.map(i=>z(i))})},onChainChanged(t){const i=Number(t);a.emitter.emit("change",{chainId:i})},async onDisconnect(){a.emitter.emit("disconnect");const t=await this.getProvider();d&&(t.removeListener("accountsChanged",d),d=void 0),l&&(t.removeListener("chainChanged",l),l=void 0),w&&(t.removeListener("disconnect",w),w=void 0)}}))}Z.type="metaMask";function Z(g={}){let I,d,l,w,a,t,i,c;return S(o=>({id:"metaMaskSDK",name:"MetaMask",rdns:["io.metamask","io.metamask.mobile"],type:Z.type,async setup(){const e=await this.getProvider();e!=null&&e.on&&(t||(t=this.onConnect.bind(this),e.on("connect",t)),w||(w=this.onAccountsChanged.bind(this),e.on("accountsChanged",w)))},async connect({chainId:e,isReconnecting:s,withCapabilities:n}={}){const r=await this.getProvider();i||(i=this.onDisplayUri,r.on("display_uri",i));let h=[];s&&(h=await this.getAccounts().catch(()=>[]));try{let M,y;h!=null&&h.length||(g.connectAndSign||g.connectWith?(g.connectAndSign?M=await I.connectAndSign({msg:g.connectAndSign}):g.connectWith&&(y=await I.connectWith({method:g.connectWith.method,params:g.connectWith.params})),h=await this.getAccounts()):h=(await I.connect()).map(p=>z(p)));let u=await this.getChainId();if(e&&u!==e){const f=await this.switchChain({chainId:e}).catch(p=>{if(p.code===j.code)throw p;return{id:u}});u=(f==null?void 0:f.id)??u}return i&&(r.removeListener("display_uri",i),i=void 0),M?r.emit("connectAndSign",{accounts:h,chainId:u,signResponse:M}):y&&r.emit("connectWith",{accounts:h,chainId:u,connectWithResponse:y}),t&&(r.removeListener("connect",t),t=void 0),w||(w=this.onAccountsChanged.bind(this),r.on("accountsChanged",w)),a||(a=this.onChainChanged.bind(this),r.on("chainChanged",a)),c||(c=this.onDisconnect.bind(this),r.on("disconnect",c)),{accounts:n?h.map(f=>({address:f,capabilities:{}})):h,chainId:u}}catch(M){const y=M;throw y.code===j.code?new j(y):y.code===Y.code?new Y(y):y}},async disconnect(){const e=await this.getProvider();a&&(e.removeListener("chainChanged",a),a=void 0),c&&(e.removeListener("disconnect",c),c=void 0),t||(t=this.onConnect.bind(this),e.on("connect",t)),await I.terminate()},async getAccounts(){return(await(await this.getProvider()).request({method:"eth_accounts"})).map(n=>z(n))},async getChainId(){const e=await this.getProvider(),s=e.getChainId()||await(e==null?void 0:e.request({method:"eth_chainId"}));return Number(s)},async getProvider(){async function e(){var M,y,u,f,p;const s=await(async()=>{const{default:D}=await(()=>{try{return L(()=>import("./connectors-BIqtKyuJ.js"),[])}catch{throw new Error('dependency "@metamask/sdk" not found')}})();return typeof D!="function"&&typeof D.default=="function"?D.default:D})(),n={};for(const D of o.chains)n[C(D.id)]=(M=q({chain:D,transports:o.transports}))==null?void 0:M[0];I=new s({...g,_source:"wagmi",forceDeleteProvider:!1,forceInjectProvider:!1,injectProvider:!1,readonlyRPCMap:n,dappMetadata:{...g.dappMetadata,name:(y=g.dappMetadata)!=null&&y.name?(u=g.dappMetadata)==null?void 0:u.name:"wagmi",url:(f=g.dappMetadata)!=null&&f.url?(p=g.dappMetadata)==null?void 0:p.url:typeof window<"u"?window.location.origin:"https://wagmi.sh"},useDeeplink:!0});const r=await I.init(),h=r!=null&&r.activeProvider?r.activeProvider:I.getProvider();if(!h)throw new T;return h}return d||(l||(l=e()),d=await l),d},async isAuthorized(){try{return!!(await m(()=>E(()=>this.getAccounts(),{timeout:200}),{delay:201,retryCount:3})).length}catch{return!1}},async switchChain({addEthereumChainParameter:e,chainId:s}){var y,u;const n=await this.getProvider(),r=o.chains.find(f=>f.id===s);if(!r)throw new O(new b);try{return await n.request({method:"wallet_switchEthereumChain",params:[{chainId:C(s)}]}),await h(),await M(s),r}catch(f){const p=f;if(p.code===j.code)throw new j(p);if(p.code===4902||((u=(y=p==null?void 0:p.data)==null?void 0:y.originalError)==null?void 0:u.code)===4902)try{return await n.request({method:"wallet_addEthereumChain",params:[{blockExplorerUrls:(()=>{const{default:D,...N}=r.blockExplorers??{};if(e!=null&&e.blockExplorerUrls)return e.blockExplorerUrls;if(D)return[D.url,...Object.values(N).map(A=>A.url)]})(),chainId:C(s),chainName:(e==null?void 0:e.chainName)??r.name,iconUrls:e==null?void 0:e.iconUrls,nativeCurrency:(e==null?void 0:e.nativeCurrency)??r.nativeCurrency,rpcUrls:(()=>{var D,N;return(D=e==null?void 0:e.rpcUrls)!=null&&D.length?e.rpcUrls:[((N=r.rpcUrls.default)==null?void 0:N.http[0])??""]})()}]}),await h(),await M(s),r}catch(D){const N=D;throw N.code===j.code?new j(N):new O(N)}throw new O(p)}async function h(){await m(async()=>{const f=K(await n.request({method:"eth_chainId"}));if(f!==s)throw new Error("User rejected switch after adding network.");return f},{delay:50,retryCount:20})}async function M(f){await new Promise(p=>{const D=N=>{"chainId"in N&&N.chainId===f&&(o.emitter.off("change",D),p())};o.emitter.on("change",D),o.emitter.emit("change",{chainId:f})})}},async onAccountsChanged(e){if(e.length===0)if(I.isExtensionActive())this.onDisconnect();else return;else if(o.emitter.listenerCount("connect")){const s=(await this.getChainId()).toString();this.onConnect({chainId:s})}else o.emitter.emit("change",{accounts:e.map(s=>z(s))})},onChainChanged(e){const s=Number(e);o.emitter.emit("change",{chainId:s})},async onConnect(e){const s=await this.getAccounts();if(s.length===0)return;const n=Number(e.chainId);o.emitter.emit("connect",{accounts:s,chainId:n});const r=await this.getProvider();t&&(r.removeListener("connect",t),t=void 0),w||(w=this.onAccountsChanged.bind(this),r.on("accountsChanged",w)),a||(a=this.onChainChanged.bind(this),r.on("chainChanged",a)),c||(c=this.onDisconnect.bind(this),r.on("disconnect",c))},async onDisconnect(e){const s=await this.getProvider();e&&e.code===1013&&s&&(await this.getAccounts()).length||(o.emitter.emit("disconnect"),a&&(s.removeListener("chainChanged",a),a=void 0),c&&(s.removeListener("disconnect",c),c=void 0),t||(t=this.onConnect.bind(this),s.on("connect",t)))},onDisplayUri(e){o.emitter.emit("message",{type:"display_uri",data:e})}}))}function nt(g={}){return S(I=>{const d=I.chains??g.chains??[],l=I.transports?I.transports:g.transports;let w,a,t,i,c;return{async connect({chainId:o=d[0].id,...e}={}){const s="isReconnecting"in e&&e.isReconnecting||!1,n="withCapabilities"in e&&e.withCapabilities||!1;let r=[],h;if(s&&([r,h]=await Promise.all([this.getAccounts().catch(()=>[]),this.getChainId().catch(()=>{})]),o&&h!==o)){const y=await this.switchChain({chainId:o}).catch(u=>{if(u.code===j.code)throw u;return{id:h}});h=(y==null?void 0:y.id)??h}const M=await this.getProvider();try{if(!(r!=null&&r.length)&&!s){const{RpcSchema:y}=await(()=>{try{return L(()=>import("./connectors-Jtxqs-vw.js"),[])}catch{throw new Error('dependency "porto" not found')}})(),{z:u}=await(()=>{try{return L(()=>import("./connectors-BwFb0NsY.js"),[])}catch{throw new Error('dependency "porto/internal" not found')}})(),f=await M.request({method:"wallet_connect",params:[{..."capabilities"in e?{capabilities:u.encode(y.wallet_connect.Capabilities,e.capabilities??{})}:{},chainIds:[C(o),...d.filter(p=>p.id!==o).map(p=>C(p.id))]}]});r=f.accounts,h=Number(f.chainIds[0])}if(!h)throw new b;return i&&(M.removeListener("connect",i),i=void 0),a||(a=this.onAccountsChanged.bind(this),M.on("accountsChanged",a)),t||(t=this.onChainChanged.bind(this),M.on("chainChanged",t)),c||(c=this.onDisconnect.bind(this),M.on("disconnect",c)),{accounts:r.map(y=>typeof y=="object"?n?y:y.address:n?{address:y,capabilities:{}}:y),chainId:h}}catch(y){const u=y;throw u.code===j.code?new j(u):u}},async disconnect(){const o=await this.getProvider();t&&(o.removeListener("chainChanged",t),t=void 0),c&&(o.removeListener("disconnect",c),c=void 0),i||(i=this.onConnect.bind(this),o.on("connect",i)),await o.request({method:"wallet_disconnect"})},async getAccounts(){return(await(await this.getProvider()).request({method:"eth_accounts"})).map(s=>z(s))},async getChainId(){const e=await(await this.getProvider()).request({method:"eth_chainId"});return Number(e)},async getPortoInstance(){return w??(w=(async()=>{const{Porto:o}=await(()=>{try{return L(()=>import("./connectors-Jtxqs-vw.js"),[])}catch{throw new Error('dependency "porto" not found')}})();return o.create({...g,announceProvider:!1,chains:d,transports:l})})()),await w},async getProvider(){return(await this.getPortoInstance()).provider},icon:"data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNDIyIiBoZWlnaHQ9IjQyMiIgdmlld0JveD0iMCAwIDQyMiA0MjIiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+CjxyZWN0IHdpZHRoPSI0MjIiIGhlaWdodD0iNDIyIiBmaWxsPSJibGFjayIvPgo8ZyBjbGlwLXBhdGg9InVybCgjY2xpcDBfMV8xNSkiPgo8cGF0aCBkPSJNODEgMjg2LjM2NkM4MSAyODAuODkzIDg1LjQ1MDUgMjc2LjQ1NSA5MC45NDA0IDI3Ni40NTVIMzI5LjUxMUMzMzUuMDAxIDI3Ni40NTUgMzM5LjQ1MiAyODAuODkzIDMzOS40NTIgMjg2LjM2NlYzMDYuMTg4QzMzOS40NTIgMzExLjY2MiAzMzUuMDAxIDMxNi4wOTkgMzI5LjUxMSAzMTYuMDk5SDkwLjk0MDRDODUuNDUwNSAzMTYuMDk5IDgxIDMxMS42NjIgODEgMzA2LjE4OFYyODYuMzY2WiIgZmlsbD0id2hpdGUiIGZpbGwtb3BhY2l0eT0iMC41Ii8+CjxwYXRoIGZpbGwtcnVsZT0iZXZlbm9kZCIgY2xpcC1ydWxlPSJldmVub2RkIiBkPSJNOTAuOTQwNCAyMzQuODI4Qzg1LjQ1MDUgMjM0LjgyOCA4MSAyMzkuMjY2IDgxIDI0NC43MzlWMjcxLjUzMUM4My44NDMyIDI2OS42MzMgODcuMjYyMiAyNjguNTI2IDkwLjk0MDQgMjY4LjUyNkgzMjkuNTExQzMzMy4xODggMjY4LjUyNiAzMzYuNjA4IDI2OS42MzMgMzM5LjQ1MiAyNzEuNTMxVjI0NC43MzlDMzM5LjQ1MiAyMzkuMjY2IDMzNS4wMDEgMjM0LjgyOCAzMjkuNTExIDIzNC44MjhIOTAuOTQwNFpNMzM5LjQ1MiAyODYuMzY2QzMzOS40NTIgMjgwLjg5MyAzMzUuMDAxIDI3Ni40NTUgMzI5LjUxMSAyNzYuNDU1SDkwLjk0MDRDODUuNDUwNSAyNzYuNDU1IDgxIDI4MC44OTMgODEgMjg2LjM2NlYzMDYuMTlDODEgMzExLjY2NCA4NS40NTA1IDMxNi4xMDEgOTAuOTQwNCAzMTYuMTAxSDMyOS41MTFDMzM1LjAwMSAzMTYuMTAxIDMzOS40NTIgMzExLjY2NCAzMzkuNDUyIDMwNi4xOVYyODYuMzY2WiIgZmlsbD0id2hpdGUiIGZpbGwtb3BhY2l0eT0iMC41Ii8+CjxwYXRoIGZpbGwtcnVsZT0iZXZlbm9kZCIgY2xpcC1ydWxlPSJldmVub2RkIiBkPSJNOTAuOTQwNCAxOTMuMjAxQzg1LjQ1MDUgMTkzLjIwMSA4MSAxOTcuNjM4IDgxIDIwMy4xMTJWMjI5LjkwM0M4My44NDMyIDIyOC4wMDYgODcuMjYyMiAyMjYuODk5IDkwLjk0MDQgMjI2Ljg5OUgzMjkuNTExQzMzMy4xODggMjI2Ljg5OSAzMzYuNjA4IDIyOC4wMDYgMzM5LjQ1MiAyMjkuOTAzVjIwMy4xMTJDMzM5LjQ1MiAxOTcuNjM4IDMzNS4wMDEgMTkzLjIwMSAzMjkuNTExIDE5My4yMDFIOTAuOTQwNFpNMzM5LjQ1MiAyNDQuNzM5QzMzOS40NTIgMjM5LjI2NSAzMzUuMDAxIDIzNC44MjggMzI5LjUxMSAyMzQuODI4SDkwLjk0MDRDODUuNDUwNSAyMzQuODI4IDgxIDIzOS4yNjUgODEgMjQ0LjczOVYyNzEuNTNDODEuMjE3NSAyNzEuMzg1IDgxLjQzODMgMjcxLjI0NSA4MS42NjI0IDI3MS4xMDlDODMuODMyNSAyNjkuNzk0IDg2LjMwNTQgMjY4LjkyNyA4OC45NTIzIDI2OC42MzVDODkuNjA1MSAyNjguNTYzIDkwLjI2ODQgMjY4LjUyNiA5MC45NDA0IDI2OC41MjZIMzI5LjUxMUMzMzAuMTgzIDI2OC41MjYgMzMwLjg0NiAyNjguNTYzIDMzMS40OTggMjY4LjYzNUMzMzQuNDE5IDI2OC45NTcgMzM3LjEyOCAyNjkuOTggMzM5LjQ1MiAyNzEuNTNWMjQ0LjczOVpNMzM5LjQ1MiAyODYuMzY2QzMzOS40NTIgMjgxLjAyMSAzMzUuMjA2IDI3Ni42NjMgMzI5Ljg5MyAyNzYuNDYyQzMyOS43NjcgMjc2LjQ1NyAzMjkuNjQgMjc2LjQ1NSAzMjkuNTExIDI3Ni40NTVIOTAuOTQwNEM4NS40NTA1IDI3Ni40NTUgODEgMjgwLjg5MyA4MSAyODYuMzY2VjMwNi4xODhDODEgMzExLjY2MiA4NS40NTA1IDMxNi4xMDEgOTAuOTQwNCAzMTYuMTAxSDMyOS41MTFDMzM1LjAwMSAzMTYuMTAxIDMzOS40NTIgMzExLjY2MiAzMzkuNDUyIDMwNi4xODhWMjg2LjM2NloiIGZpbGw9IndoaXRlIiBmaWxsLW9wYWNpdHk9IjAuNSIvPgo8cGF0aCBvcGFjaXR5PSIwLjMiIGZpbGwtcnVsZT0iZXZlbm9kZCIgY2xpcC1ydWxlPSJldmVub2RkIiBkPSJNOTguMDE0NiAxMDRDODguNjE3NyAxMDQgODEgMTExLjU5NSA4MSAxMjAuOTY1VjE4OC4yNzZDODMuODQzMiAxODYuMzc5IDg3LjI2MjIgMTg1LjI3MiA5MC45NDA0IDE4NS4yNzJIMzI5LjUxMUMzMzMuMTg4IDE4NS4yNzIgMzM2LjYwOCAxODYuMzc5IDMzOS40NTIgMTg4LjI3NlYxMjAuOTY1QzMzOS40NTIgMTExLjU5NSAzMzEuODMzIDEwNCAzMjIuNDM3IDEwNEg5OC4wMTQ2Wk0zMzkuNDUyIDIwMy4xMTJDMzM5LjQ1MiAxOTcuNjM4IDMzNS4wMDEgMTkzLjIwMSAzMjkuNTExIDE5My4yMDFIOTAuOTQwNEM4NS40NTA1IDE5My4yMDEgODEgMTk3LjYzOCA4MSAyMDMuMTEyVjIyOS45MDNDODEuMjE3NSAyMjkuNzU4IDgxLjQzODMgMjI5LjYxOCA4MS42NjI0IDIyOS40ODJDODMuODMyNSAyMjguMTY3IDg2LjMwNTQgMjI3LjMgODguOTUyMyAyMjcuMDA4Qzg5LjYwNTEgMjI2LjkzNiA5MC4yNjg0IDIyNi44OTkgOTAuOTQwNCAyMjYuODk5SDMyOS41MTFDMzMwLjE4MyAyMjYuODk5IDMzMC44NDYgMjI2LjkzNiAzMzEuNDk4IDIyNy4wMDhDMzM0LjQxOSAyMjcuMzMgMzM3LjEyOCAyMjguMzUyIDMzOS40NTIgMjI5LjkwM1YyMDMuMTEyWk0zMzkuNDUyIDI0NC43MzlDMzM5LjQ1MiAyMzkuMzkzIDMzNS4yMDYgMjM1LjAzNiAzMjkuODkzIDIzNC44MzVDMzI5Ljc2NyAyMzQuODMgMzI5LjY0IDIzNC44MjggMzI5LjUxMSAyMzQuODI4SDkwLjk0MDRDODUuNDUwNSAyMzQuODI4IDgxIDIzOS4yNjUgODEgMjQ0LjczOVYyNzEuNTNMODEuMDcwNyAyNzEuNDgzQzgxLjI2NTMgMjcxLjM1NSA4MS40NjI1IDI3MS4yMyA4MS42NjI0IDI3MS4xMDlDODEuOTA4MyAyNzAuOTYgODIuMTU4MSAyNzAuODE3IDgyLjQxMTcgMjcwLjY3OUM4NC4zOTUzIDI2OS42MDUgODYuNjA1NCAyNjguODk0IDg4Ljk1MjMgMjY4LjYzNUM4OS4wMDUyIDI2OC42MjkgODkuMDU4IDI2OC42MjQgODkuMTExIDI2OC42MThDODkuNzEyNSAyNjguNTU3IDkwLjMyMjggMjY4LjUyNiA5MC45NDA0IDI2OC41MjZIMzI5LjUxMUMzMjkuNzM4IDI2OC41MjYgMzI5Ljk2NSAyNjguNTMgMzMwLjE5MiAyNjguNTM5QzMzMC42MzEgMjY4LjU1NSAzMzEuMDY3IDI2OC41ODcgMzMxLjQ5OCAyNjguNjM1QzMzNC40MTkgMjY4Ljk1NyAzMzcuMTI4IDI2OS45OCAzMzkuNDUyIDI3MS41M1YyNDQuNzM5Wk0zMzkuNDUyIDI4Ni4zNjZDMzM5LjQ1MiAyODEuMDIxIDMzNS4yMDYgMjc2LjY2MyAzMjkuODkzIDI3Ni40NjJMMzI5Ljg2NSAyNzYuNDYxQzMyOS43NDggMjc2LjQ1NyAzMjkuNjI5IDI3Ni40NTUgMzI5LjUxMSAyNzYuNDU1SDkwLjk0MDRDODUuNDUwNSAyNzYuNDU1IDgxIDI4MC44OTMgODEgMjg2LjM2NlYzMDYuMTg4QzgxIDMxMS42NjIgODUuNDUwNSAzMTYuMTAxIDkwLjk0MDQgMzE2LjEwMUgzMjkuNTExQzMzNS4wMDEgMzE2LjEwMSAzMzkuNDUyIDMxMS42NjIgMzM5LjQ1MiAzMDYuMTg4VjI4Ni4zNjZaIiBmaWxsPSJ3aGl0ZSIvPgo8cGF0aCBkPSJNMjY5Ljg2OCAxMzEuNzUyQzI2OS44NjggMTI2LjI3OCAyNzQuMzE4IDEyMS44NCAyNzkuODA4IDEyMS44NEgzMTEuNjE4QzMxNy4xMDggMTIxLjg0IDMyMS41NTggMTI2LjI3OCAzMjEuNTU4IDEzMS43NTJWMTYxLjQ4NUMzMjEuNTU4IDE2Ni45NTkgMzE3LjEwOCAxNzEuMzk2IDMxMS42MTggMTcxLjM5NkgyNzkuODA4QzI3NC4zMTggMTcxLjM5NiAyNjkuODY4IDE2Ni45NTkgMjY5Ljg2OCAxNjEuNDg1VjEzMS43NTJaIiBmaWxsPSJ3aGl0ZSIvPgo8L2c+CjxkZWZzPgo8Y2xpcFBhdGggaWQ9ImNsaXAwXzFfMTUiPgo8cmVjdCB3aWR0aD0iMjU5IiBoZWlnaHQ9IjIxMyIgZmlsbD0id2hpdGUiIHRyYW5zZm9ybT0idHJhbnNsYXRlKDgxIDEwNCkiLz4KPC9jbGlwUGF0aD4KPC9kZWZzPgo8L3N2Zz4K",id:"xyz.ithaca.porto",async isAuthorized(){try{return!!(await m(()=>this.getAccounts())).length}catch{return!1}},name:"Porto",async onAccountsChanged(o){I.emitter.emit("change",{accounts:o.map(e=>z(e))})},onChainChanged(o){const e=Number(o);I.emitter.emit("change",{chainId:e})},async onConnect(o){const e=await this.getAccounts();if(e.length===0)return;const s=Number(o.chainId);I.emitter.emit("connect",{accounts:e,chainId:s});const n=await this.getProvider();n&&(i&&(n.removeListener("connect",i),i=void 0),a||(a=this.onAccountsChanged.bind(this),n.on("accountsChanged",a)),t||(t=this.onChainChanged.bind(this),n.on("chainChanged",t)),c||(c=this.onDisconnect.bind(this),n.on("disconnect",c)))},async onDisconnect(o){const e=await this.getProvider();I.emitter.emit("disconnect"),e&&(t&&(e.removeListener("chainChanged",t),t=void 0),c&&(e.removeListener("disconnect",c),c=void 0),i||(i=this.onConnect.bind(this),e.on("connect",i)))},async setup(){if(!i){const o=await this.getProvider();i=this.onConnect.bind(this),o.on("connect",i)}},async switchChain({chainId:o}){const e=d.find(n=>n.id===o);if(!e)throw new O(new b);return await(await this.getProvider()).request({method:"wallet_switchEthereumChain",params:[{chainId:C(o)}]}),e},type:"injected"}})}V.type="safe";function V(g={}){const{shimDisconnect:I=!1}=g;let d,l;return S(w=>({id:"safe",name:"Safe",type:V.type,async connect({withCapabilities:a}={}){var o;const t=await this.getProvider();if(!t)throw new T;const i=await this.getAccounts(),c=await this.getChainId();return l||(l=this.onDisconnect.bind(this),t.on("disconnect",l)),I&&await((o=w.storage)==null?void 0:o.removeItem("safe.disconnected")),{accounts:a?i.map(e=>({address:e,capabilities:{}})):i,chainId:c}},async disconnect(){var t;const a=await this.getProvider();if(!a)throw new T;l&&(a.removeListener("disconnect",l),l=void 0),I&&await((t=w.storage)==null?void 0:t.setItem("safe.disconnected",!0))},async getAccounts(){const a=await this.getProvider();if(!a)throw new T;return(await a.request({method:"eth_accounts"})).map(z)},async getProvider(){if(typeof window<"u"&&(window==null?void 0:window.parent)!==window){if(!d){const{default:t}=await(()=>{try{return L(()=>import("./index-CfvKrXyt.js").then(e=>e.e),__vite__mapDeps([0,1,2,3]))}catch{throw new Error('dependency "@safe-global/safe-apps-sdk" not found')}})(),i=new t(g),c=await E(()=>i.safe.getInfo(),{timeout:g.unstable_getInfoTimeout??10});if(!c)throw new Error("Could not load Safe information");const o=await(async()=>{const e=await(()=>{try{return L(()=>import("./index-DX5vLSUl.js").then(s=>s.i),__vite__mapDeps([4,1,2,0,3]))}catch{throw new Error('dependency "@safe-global/safe-apps-provider" not found')}})();return typeof e.SafeAppProvider!="function"&&typeof e.default.SafeAppProvider=="function"?e.default.SafeAppProvider:e.SafeAppProvider})();d=new o(c,i)}return d}},async getChainId(){const a=await this.getProvider();if(!a)throw new T;return Number(a.chainId)},async isAuthorized(){var a;try{return I&&await((a=w.storage)==null?void 0:a.getItem("safe.disconnected"))?!1:!!(await this.getAccounts()).length}catch{return!1}},onAccountsChanged(){},onChainChanged(){},onDisconnect(){w.emitter.emit("disconnect")}}))}const it="7.1.7";G.type="walletConnect";function G(g){const I=g.isNewChainsStale??!0;let d,l;const w="eip155";let a,t,i,c,o,e;return S(s=>({id:"walletConnect",name:"WalletConnect",type:G.type,async setup(){const n=await this.getProvider().catch(()=>null);n&&(i||(i=this.onConnect.bind(this),n.on("connect",i)),o||(o=this.onSessionDelete.bind(this),n.on("session_delete",o)))},async connect({chainId:n,withCapabilities:r,...h}={}){var M,y;try{const u=await this.getProvider();if(!u)throw new T;c||(c=this.onDisplayUri,u.on("display_uri",c));let f=n;if(!f){const A=await((M=s.storage)==null?void 0:M.getItem("state"))??{};s.chains.some(k=>k.id===A.chainId)?f=A.chainId:f=(y=s.chains[0])==null?void 0:y.id}if(!f)throw new Error("No chains found on connector.");const p=await this.isChainsStale();if(u.session&&p&&await u.disconnect(),!u.session||p){const A=s.chains.filter(v=>v.id!==f).map(v=>v.id);await u.connect({optionalChains:[f,...A],..."pairingTopic"in h?{pairingTopic:h.pairingTopic}:{}}),this.setRequestedChainsIds(s.chains.map(v=>v.id))}const D=(await u.enable()).map(A=>z(A));let N=await this.getChainId();if(n&&N!==n){const A=await this.switchChain({chainId:n}).catch(v=>{var k;if(v.code===j.code&&((k=v.cause)==null?void 0:k.message)!=="Missing or invalid. request() method: wallet_addEthereumChain")throw v;return{id:N}});N=(A==null?void 0:A.id)??N}return c&&(u.removeListener("display_uri",c),c=void 0),i&&(u.removeListener("connect",i),i=void 0),a||(a=this.onAccountsChanged.bind(this),u.on("accountsChanged",a)),t||(t=this.onChainChanged.bind(this),u.on("chainChanged",t)),e||(e=this.onDisconnect.bind(this),u.on("disconnect",e)),o||(o=this.onSessionDelete.bind(this),u.on("session_delete",o)),{accounts:r?D.map(A=>({address:A,capabilities:{}})):D,chainId:N}}catch(u){throw/(user rejected|connection request reset)/i.test(u==null?void 0:u.message)?new j(u):u}},async disconnect(){const n=await this.getProvider();try{await(n==null?void 0:n.disconnect())}catch(r){if(!/No matching key/i.test(r.message))throw r}finally{t&&(n==null||n.removeListener("chainChanged",t),t=void 0),e&&(n==null||n.removeListener("disconnect",e),e=void 0),i||(i=this.onConnect.bind(this),n==null||n.on("connect",i)),a&&(n==null||n.removeListener("accountsChanged",a),a=void 0),o&&(n==null||n.removeListener("session_delete",o),o=void 0),this.setRequestedChainsIds([])}},async getAccounts(){return(await this.getProvider()).accounts.map(r=>z(r))},async getProvider({chainId:n}={}){var h;async function r(){const M=s.chains.map(u=>u.id);if(!M.length)return;const{EthereumProvider:y}=await(()=>{try{return L(()=>import("./connectors-Cf3PoqX8.js"),[])}catch{throw new Error('dependency "@walletconnect/ethereum-provider" not found')}})();return await y.init({...g,disableProviderPing:!0,optionalChains:M,projectId:g.projectId,rpcMap:Object.fromEntries(s.chains.map(u=>{const[f]=q({chain:u,transports:s.transports});return[u.id,f]})),showQrModal:g.showQrModal??!0})}return d||(l||(l=r()),d=await l,d==null||d.events.setMaxListeners(Number.POSITIVE_INFINITY)),n&&await((h=this.switchChain)==null?void 0:h.call(this,{chainId:n})),d},async getChainId(){return(await this.getProvider()).chainId},async isAuthorized(){try{const[n,r]=await Promise.all([this.getAccounts(),this.getProvider()]);return n.length?await this.isChainsStale()&&r.session?(await r.disconnect().catch(()=>{}),!1):!0:!1}catch{return!1}},async switchChain({addEthereumChainParameter:n,chainId:r}){var y,u,f;const h=await this.getProvider();if(!h)throw new T;const M=s.chains.find(p=>p.id===r);if(!M)throw new O(new b);try{await Promise.all([new Promise(D=>{const N=({chainId:A})=>{A===r&&(s.emitter.off("change",N),D())};s.emitter.on("change",N)}),h.request({method:"wallet_switchEthereumChain",params:[{chainId:C(r)}]})]);const p=await this.getRequestedChainsIds();return this.setRequestedChainsIds([...p,r]),M}catch(p){const D=p;if(/(user rejected)/i.test(D.message))throw new j(D);try{let N;n!=null&&n.blockExplorerUrls?N=n.blockExplorerUrls:N=(y=M.blockExplorers)!=null&&y.default.url?[(u=M.blockExplorers)==null?void 0:u.default.url]:[];let A;(f=n==null?void 0:n.rpcUrls)!=null&&f.length?A=n.rpcUrls:A=[...M.rpcUrls.default.http];const v={blockExplorerUrls:N,chainId:C(r),chainName:(n==null?void 0:n.chainName)??M.name,iconUrls:n==null?void 0:n.iconUrls,nativeCurrency:(n==null?void 0:n.nativeCurrency)??M.nativeCurrency,rpcUrls:A};await h.request({method:"wallet_addEthereumChain",params:[v]});const k=await this.getRequestedChainsIds();return this.setRequestedChainsIds([...k,r]),M}catch(N){throw new j(N)}}},onAccountsChanged(n){n.length===0?this.onDisconnect():s.emitter.emit("change",{accounts:n.map(r=>z(r))})},onChainChanged(n){const r=Number(n);s.emitter.emit("change",{chainId:r})},async onConnect(n){const r=Number(n.chainId),h=await this.getAccounts();s.emitter.emit("connect",{accounts:h,chainId:r})},async onDisconnect(n){this.setRequestedChainsIds([]),s.emitter.emit("disconnect");const r=await this.getProvider();a&&(r.removeListener("accountsChanged",a),a=void 0),t&&(r.removeListener("chainChanged",t),t=void 0),e&&(r.removeListener("disconnect",e),e=void 0),o&&(r.removeListener("session_delete",o),o=void 0),i||(i=this.onConnect.bind(this),r.on("connect",i))},onDisplayUri(n){s.emitter.emit("message",{type:"display_uri",data:n})},onSessionDelete(){this.onDisconnect()},getNamespaceChainsIds(){var r,h,M;return d?((M=(h=(r=d.session)==null?void 0:r.namespaces[w])==null?void 0:h.accounts)==null?void 0:M.map(y=>Number.parseInt(y.split(":")[1]||"",10)))??[]:[]},async getRequestedChainsIds(){var n;return await((n=s.storage)==null?void 0:n.getItem(this.requestedChainsStorageKey))??[]},async isChainsStale(){if(!I)return!1;const n=s.chains.map(M=>M.id),r=this.getNamespaceChainsIds();if(r.length&&!r.some(M=>n.includes(M)))return!1;const h=await this.getRequestedChainsIds();return!n.every(M=>h.includes(M))},async setRequestedChainsIds(n){var r;await((r=s.storage)==null?void 0:r.setItem(this.requestedChainsStorageKey,n))},get requestedChainsStorageKey(){return`${this.id}.requestedChains`}}))}export{et as baseAccount,R as coinbaseWallet,W as gemini,ot as injected,Z as metaMask,Q as mock,nt as porto,V as safe,it as version,G as walletConnect};
